
#include <assert.h>
#include <stdio.h>
char* strcat1(char *des,const char *src)
{
    assert((des != NULL) && (src != NULL));
    char *address = des;
    while(*des != '\0')
        ++des;
    while((*des++ = *src++) != '\0')
        ;
    return address;
}
int main(){
    char str1[30] = "i want to go ";
    char *str2 = "japan";
    printf("%s\n",strcat1(str1,str2));
    return 0;
}
#include <assert.h>
#include <stdio.h>
int strcmp1(const char *str1,const char *str2)
{
    assert((str1 != NULL) && (str2 != NULL));
    int ret = 0;
    while(!(ret = *(unsigned char *)str1 - *(unsigned char *)str2) && *str1){
        ++str1;
        ++str2;
    }
    return *str1 - *str2;
}
int strcmp2(const char *str1,const char *str2)
{
    assert((str1 != NULL) && (str2 != NULL));
    while(*str1 == *str2){
        ++str1;
        ++str2;
    }
    return *str1 - *str2;
}
int main(){
    char *str1 = "i want";
    char *str2 = "i wan";
    printf("%d\n",strcmp1(str1,str2));
    printf("%d\n",strcmp2(str1,str2));
    return 0;
}
#include <stdio.h>
#include <assert.h>
#include <string.h>
char *strcpy1(char *des,const char *src){
    assert((des != NULL) && (src != NULL));
    char *address = des;
    while((*des++ = *src++) != '\0')
        ;
    return address;
}

char *strcpy2(char *des,const char *src)
{
    assert((des != NULL) && (src != NULL));
    int size = strlen(src);
    char *pDes = NULL;
    //overlap
    if(src < des && src + size > des){
        src = src + size - 1;
        pDes = des + size - 1;
        while(size --)
            *pDes-- = *src--;
    }
    //no overlap
    else{
        pDes = des;
        while(size--)
            *pDes++ = *src++;
    }
    return pDes;
}
int main()
{
    char str[20] = "linux";
    strcpy2(str + 8,str);
}
#include <assert.h>
#include <stdio.h>
int strlen1(const char *str)
{
    assert(str != NULL);
    int len = 0;
    while((*str ++) != '\0')
        ++len;
    return len;
}
int main()
{
    /*
     *what's the difference between char * and char [] ?
     *char * will place str in read-only parts of the memory,and making str a pointer to that
     *makes any writing operation on this memory is illegal.
     *char [] puts the str in rad-only memory and copies the str to newly allocated memory on the stack.
    */
    char *str1 = "linux";
    char str2[] = "redhat";
    char str3[10] = "chinese";
    //str1[0] = 'Q'; //illegal
    str2[0] = 'Q';  //legal
    str3[8] = 'Q';  //legal
    printf("%d\n",strlen1(str1));
    printf("%d\n",strlen1(str2));
    printf("%d\n",strlen1(str3));
    return 0;
}


---------------
#include <iostream>
#include <queue>
using namespace std;
template<typename T>
class BTNode{
    public:
        T val;
        BTNode<T> *right;
        BTNode<T> *left;
        BTNode<T> *parent;//for bst
        BTNode():val(T()),right(nullptr),left(nullptr)
        {

        };
        BTNode(T v,BTNode<T> *pRight = nullptr,BTNode<T> *pLeft = nullptr):val(v),right(pRight),left(pLeft)
        {

        };
};
template<typename T>
class BinaryTree{
    public:
        BTNode<T> *root;

        BinaryTree():root(nullptr){};
        ~BinaryTree(){};
        //Construct binary tree from preOrder and MidOrder
        void ConstructTree(BTNode<T> * &root,T *PreOrder,T *MidOrder,int Len);
        //Construct binary search tree from array
        void ConstructBST(BTNode<T> * &root,T *arr);
        void PreTraversing(BTNode<T> * &root);
        void InTraversing(BTNode<T> * &root) ;
        void PostTraversing(BTNode<T> * &root);
        void LevelTraversing(BTNode<T> * &root);
        int GetTreeDepth(BTNode<T> * &root);
};
template<typename T>
void BinaryTree<T>::ConstructTree(BTNode<T> * &root,T *PreOrder,T *MidOrder,int Len){
    T rootVal = PreOrder[0];
    root = new BTNode<T>(rootVal);
    if(Len == 1 && PreOrder[0] == MidOrder[0])
        return;
    //find root position in MidOrder
    T *rootInMid = MidOrder;
    int leftLen = 0;
    while(rootInMid < MidOrder + Len && *rootInMid != rootVal){
        ++rootInMid;
        ++leftLen;
    }
    if(*rootInMid != rootVal)
        return ;
    if(leftLen > 0)
        ConstructTree(root->left,PreOrder + 1,MidOrder,leftLen);
    if(Len - leftLen - 1 > 0)
        ConstructTree(root->right,PreOrder + leftLen + 1,rootInMid + 1,Len - leftLen - 1);
}
template<typename T>
void BinaryTree<T>::PreTraversing(BTNode<T> * &root){
    if(root){
        cout<<root->val<<" ";
        PreTraversing(root->left);
        PreTraversing(root->right);
    }
}
template<typename T>
void BinaryTree<T>::InTraversing(BTNode<T> * &root){
    if(root){
        InTraversing(root->left);
        cout<<" "<<root->val<<" ";
        InTraversing(root->right);
    }
}
template<typename T>
void BinaryTree<T>::PostTraversing(BTNode<T> * &root){
    if(root){
        PostTraversing(root->left);
        PostTraversing(root->right);
        cout<<" "<<root->val<<" ";
    }
}
template<typename T>
void BinaryTree<T>::LevelTraversing(BTNode<T> * &root){
    if(!root)
        return;
    queue< BTNode<T>* > nodeQ;
    nodeQ.push(root);
    int parentSz = 1,childSz = 0;
    do
    {
        BTNode<T> *cur = nodeQ.front();
        cout<<" "<<cur->val<<" ";
        nodeQ.pop();
        if(cur->left){
            nodeQ.push(cur->left);
            ++ childSz;
        }
        if(cur->right){
            nodeQ.push(cur->right);
            ++ childSz;
        }
        --parentSz;
        if(parentSz == 0){
            parentSz = childSz;
            childSz = 0;
            cout<<endl;
        }
    }while(!nodeQ.empty());
}
template<typename T>
int BinaryTree<T>::GetTreeDepth(BTNode<T> * &root){
    if(!root)
        return 0;
    int leftDepth = GetTreeDepth(root->left);
    int rightDepth = GetTreeDepth(root->right);
    return leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1;
}
class Test{
    int i;
    int &a = i;
};
int main()
{
    BinaryTree<int> tree;
    int preOrder[] = {1,2,4,6,7,8,3,5};
    int midOrder[] = {4,7,6,8,2,1,3,5};
    tree.ConstructTree(tree.root,preOrder,midOrder,8);
    tree.PreTraversing(tree.root);
    cout<<endl;
    tree.InTraversing(tree.root);
    cout<<endl;
    tree.PostTraversing(tree.root);     ;
    cout<<endl;
    tree.LevelTraversing(tree.root);
    cout<<endl;
    cout<<"Depth :"<<tree.GetTreeDepth(tree.root)<<endl;
    return 0;
}
